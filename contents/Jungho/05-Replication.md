# Replication

> 일반적인 분산 시스템에서는 애플리케이션의 고가용성을 위해 내부적으로 리플리케이션 동작을 하게 되는데, 이러한 리플리케이션 동작의 구현은 매우 어려운 부분일 뿐만 아니라 애플리케이션의 성능 저하도 불러오게 된다.

이를 보완하기 위해 카프카는 안정성을 높이과 동시에 최대한 성능에 영향을 주지 않도록 설계되었다. 카프카는 브로커의 장애에도 불구하고 연속적으로 안정적인 서비스를 제공함으로써 데이터 유실을 방지하며 유연성을 제공한다. 카프카의 리플리케이션 동작을 위해 토픽 생성 시 필수값으로 `replication factor` 를 설정해야 한다.

jungho-kafak01 ~ 03 까지의 브로커가 있다고 가정하고, 01 브로커로 메시지를 보낸 후, 02, 03 브로커에 들어가서 dump 명령어를 통해 결과를 확인해보면 모든 브로커가 동일한 메시지를 가지고 있음을 알 수 있다.

즉, N 개의 리플리케이션이 있는 경우 N-1 까지의 브로커 장애가 발생해도 메시지 손실 없이 안정적으로 메시지를 주고 받을 수 있다.

## 리더, 팔로워

카프카는 내부적으로 모두 동일한 리플리케이션들을 리더와 팔로워로 구분하고, 각자의 역할을 분담시킨다. 리더는 리플리케이션 중 하나가 선정되며, __모든 읽기와 쓰기는 그 리더를 통해서만 가능__ 하다.

즉, 프로듀서는 모든 리플리케이션에 메시지를 보내는 것이 아니라 `리더`에게만 메시지를 전송한다.

팔로워는 리더에게 문제가 생겼을 때를 대비해 언제든지 새로운 리더가 될 준비를 하고 있다. 따라서 팔로워는 파티션의 리더가 새로운 메시지를 받았는지 확인하고, 새로운 메시지가 있다면 해당 메시지를 리더로부터 복제한다.

## ISR(InSyncReplica)

- 리더와 팔로워는 ISR 이라는 그룹으로 묶여있다. 
- 그룹으로 나누는 이유는 해당 그룹 안에 속한 팔로워만 새로운 리더의 자격을 가질 수 있기 때문이다.
- ISR 내의 팔로워들은 리더와의 데이터 일치를 유지하기 위해 지속적으로 리더의 데이터를 따라가게 되고, 리더는 ISR 내의 모든 팔로워가 메시지를 받을 때 까지 기다린다.
  - 팔로워가 네트워크 오류, 브로커 장애 등의 이유로 리더로부터 리플리케이션하지 못하는 경우에 리더가 팔로워에게 리더 자격을 넘겨주면 문제가 된다.
  - 따라서, 리더는 팔로워들이 리플리케이션 동작을 잘 하고 있는지 감시한다.
- ISR 내에서 모든 팔로원의 복제가 완료되면 리더는 내부적으로 커밋되었다는 표시를 하게 된다.
  - 마지막 커밋 오프셋 위치를 `하이워터마크(high water mark)` 라고 부른다.
  - __커밋된 메시지만 컨슈머가 읽어갈 수 있다.__
  - 따라서, 커밋된 위치를 아는 것이 중요하다.
- 어떻게 커밋된 위치를 알 수 있는지?
  - 모든 브로커는 재시작될 때, 커밋된 메시지를 유지하기 위해 로컬 디스크의 `replication-offset-checkpoint` 라는 파일에 마지막 커밋 오프셋 위치를 저장한다.

## 리더와 팔로워의 통신 과정

- 카프카는 리더와 팔로워간 통신을 할 때, ACK 을 주고받는 통신이 없다. 
- 카프카는 리더와 팔로워들의 리플리케이션 동작 방식에서 리더가 push 하는 방식이 아닌, 팔로워가 pull 하는 방식으로 동작한다.

이러한 이유는 리플리케이션 동작에서 리더의 부하를 줄여주고 성능상 이점을 끌어올리기 위해서이다.

## 리더에포크와 복구

- 리더에포크(LeaderEpoch)는 카프카의 파티션들이 복구 동작을 할 때, 메시지의 일관성을 유지하기 위한 용도로 이용된다.
- 리더에포크 정보는 리플리케이션 프로토콜에 의해 전파되고, 새로운 리더가 변경된 후 변경된 리더에 대한 정보는 팔로워에게 전달된다.
- 리더에포크는 복구 동작 시 하이워터마크를 대체하는 수단으로도 활용된다.

## 컨트롤러

- 컨트롤러는 리더 선출 책임을 맡는다.
- 카프카 클러스터 중 하나의 브로커가 컨트롤러 역할을 하며, 파티션의 ISR 리스트 중에서 리더를 선출한다.
  - 리더를 선출하기 위한 ISR 정보는 가용성을 위해 주키퍼에 저장되어있다.
- 만약, 브로커의 실패가 감지되면 즉시 ISR 리스트 중 하나를 새로운 파티션 리더로 선출한다. 그리고 나서 새로운 리더의 정보를 주키퍼에 기록하고, 변경된 정보를 모든 브로커에게 전달한다.
